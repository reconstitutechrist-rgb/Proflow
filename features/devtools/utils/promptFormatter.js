/**
 * Formats a bug report into a Claude-ready prompt
 */
export function formatBugReportPrompt({
  description,
  route,
  componentPath,
  componentName,
  selector,
  dimensions,
  elements = [],
  groups = [],
  viewportSize,
  requestedChange,
  hasAnnotatedScreenshot,
  annotationCount = 0,
}) {
  // Extract page name from route
  const pageName = getPageNameFromRoute(route);

  // Build the prompt
  let prompt = `Fix this issue on the ${pageName} page:\n\n`;

  // Problem description
  prompt += `**Problem**: ${description || '[No description provided]'}\n\n`;

  // Location details
  prompt += `**Location**:\n`;
  prompt += `- Page: ${route}\n`;

  // Handle multiple elements
  if (elements.length > 1) {
    // Multiple elements selected
    prompt += `\n**Elements** (${elements.length} selected):\n`;

    // Show grouped elements first
    if (groups.length > 0) {
      groups.forEach((group, groupIndex) => {
        prompt += `\n*Group ${groupIndex + 1} (related elements):*\n`;
        group.forEach((elementIndex) => {
          const el = elements[elementIndex];
          if (el) {
            prompt += `  ${elementIndex + 1}. ${el.componentName || 'Unknown Component'}\n`;
            prompt += `     - Selector: \`${el.selector}\`\n`;
            if (el.dimensions?.width) {
              prompt += `     - Size: ${el.dimensions.width}x${el.dimensions.height}px\n`;
            }
          }
        });
      });
    }

    // Show ungrouped elements
    const groupedIndices = new Set(groups.flat());
    const ungroupedElements = elements
      .map((el, i) => ({ el, index: i }))
      .filter(({ index }) => !groupedIndices.has(index));

    if (ungroupedElements.length > 0) {
      if (groups.length > 0) {
        prompt += `\n*Individual elements:*\n`;
      }
      ungroupedElements.forEach(({ el, index }) => {
        prompt += `${index + 1}. ${el.componentName || 'Unknown Component'}\n`;
        prompt += `   - Selector: \`${el.selector}\`\n`;
        if (el.componentPath) {
          prompt += `   - File: ${el.componentPath}\n`;
        }
        if (el.dimensions?.width) {
          prompt += `   - Size: ${el.dimensions.width}x${el.dimensions.height}px\n`;
        }
      });
    }
  } else if (elements.length === 1) {
    // Single element from array
    const el = elements[0];
    if (el.componentPath) {
      prompt += `- Component: ${el.componentPath}\n`;
    }
    if (el.componentName && el.componentName !== el.componentPath) {
      prompt += `- Component Name: ${el.componentName}\n`;
    }
    if (el.selector) {
      prompt += `- Element: \`${el.selector}\`\n`;
    }
    if (el.dimensions?.width) {
      prompt += `- Element Size: ${el.dimensions.width}x${el.dimensions.height}px\n`;
    }
  } else {
    // Fallback to single element props (backwards compatibility)
    if (componentPath) {
      prompt += `- Component: ${componentPath}\n`;
    }
    if (componentName && componentName !== componentPath) {
      prompt += `- Component Name: ${componentName}\n`;
    }
    if (selector) {
      prompt += `- Element: \`${selector}\`\n`;
    }
    if (dimensions && (dimensions.width || dimensions.height)) {
      prompt += `- Element Size: ${dimensions.width}x${dimensions.height}px\n`;
    }
  }

  prompt += '\n';

  // Visual reference
  if (hasAnnotatedScreenshot) {
    prompt += `**Visual Reference**: See the annotated screenshot above - `;
    if (annotationCount > 0) {
      prompt += `${annotationCount} annotation${annotationCount > 1 ? 's' : ''} highlight${annotationCount > 1 ? '' : 's'} the problem area${annotationCount > 1 ? 's' : ''}.\n\n`;
    } else {
      prompt += `the screenshot shows the current state.\n\n`;
    }
  }

  // Viewport info
  prompt += `**Viewport**: ${viewportSize.width}x${viewportSize.height}\n\n`;

  // Requested change
  prompt += `**Requested Change**: ${requestedChange || '[No specific change requested]'}\n`;

  // Footer
  prompt += `\n---\n*Generated by Visual Bug Reporter*`;

  return prompt;
}

/**
 * Extract a human-readable page name from a route
 */
function getPageNameFromRoute(route) {
  if (!route || route === '/') {
    return 'Home';
  }

  // Remove leading slash and split by slashes
  const parts = route.replace(/^\//, '').split('/');

  // Get the first meaningful part
  const firstPart = parts[0] || 'Home';

  // Convert to title case and handle common patterns
  return firstPart
    .replace(/([A-Z])/g, ' $1') // Add space before capital letters
    .replace(/[-_]/g, ' ') // Replace dashes and underscores with spaces
    .replace(/\b\w/g, (c) => c.toUpperCase()) // Capitalize first letter of each word
    .trim();
}

/**
 * Format a compact summary for the copy button tooltip
 */
export function formatPromptSummary({
  route,
  componentName,
  selector,
  hasDescription,
  hasRequestedChange,
}) {
  const parts = [];

  if (route) parts.push(`Page: ${route}`);
  if (componentName) parts.push(`Component: ${componentName}`);
  if (selector) parts.push(`Element: ${selector.substring(0, 30)}...`);
  if (hasDescription) parts.push('Description');
  if (hasRequestedChange) parts.push('Requested change');

  return parts.join(' | ');
}
